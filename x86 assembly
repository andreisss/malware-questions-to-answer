### The registers are categorized as being one of the following:
-- General purpose registers
-- Segment registers
-- Flag registers
-- Instruction pointers


In x86 architecture, each general purpose register has its designated purpose and is stored at WORD size, or 16 bits, as follows:
-- Accumulator (AX)
-- Counter (CX)
-- Data (DX)
-- Base (BX)
-- Stack pointer (SP)
-- Base pointer (BP)
-- Source index (SI)
-- Destination index (DI)

Endianness
When reading or writing data to memory, we use the registers or memory to process them as BYTE, WORD, DWORD, or even QWORD. Depending on the platform or program, data is read
in little-endian or big-endian form. In little-endian, a chunk of data read into a DWORD is reversed. Let's take the following piece of data as an example:
AA BB CC DD
When the data on a file or memory looks like this, in little-endian format, it will be read as DDCCBBAAh in a DWORD value. 
This endianness is common to Windows applications.
In the big-endian system, the same chunk of data will be read as AABBCCDDh.
The advantage of using the big-endian form arises when reading streaming data such as file,  serial, and network streams.
The advantage of reading in little-endian is that the address you read it from remains fixed, regardless of whether it is read as BYTE, WORD, or DWORD. For example, consider the

Address Byte
0x00000000 AA
0x00000001 00
0x00000002 00
0x00000003 00

Copying data
The MOV instruction is used to move data. With this, data is moved either to or from a register or a memory address.
mov eax, 0xaabbccdd places the 0xaabbccdd value in the eax register.
mov eax, edx places the data value from theedx register to the eax register.

; the following lines reads from memory
mov al, byte ptr [00000071] ; al = 71h
mov cx, word ptr [00000071] ; cx = 7271h
mov edx, dword ptr [00000071] ; edx = 74737271h

; the following lines writes to memory mov eax, 011223344h
mov byte ptr [00000080], al ; writes the value in al to address 00000080
mov word ptr [00000081], ax ; writes the value in ax to address 00000081
mov dword ptr [00000083], eax ; writes the value in eax to address 00000083

MOV and LEA
MOV is used to read the value at a given address, while LEA (Load Effective Address) is used to get the address instead:
mov eax, dword ptr [00000060] ; stores 63626160h to eax
mov eax, dword ptr [00000060] ; stores 00000060h to eax

; using MUL and ADD
mov ecx, 1111h
mov ebx, 2222h
mov eax, 2 ; eax = 2
mul ecx ; eax = 2222h
add eax, ebx ; eax = 4444h
add eax, 1 ; eax = 4445h

; using LEA
mov ecx, 1111h
mov ebx, 2222h
lea eax, [ecx*2+ebx+1] ; eax = 4445h
The preceding code shows that the six lines of code can be optimized to three lines using the LEA instruction.

Addition and subtraction
mov ecx, 0x7fffffff
mov ebx, 0x7fffffff

mov ecx, 0x7fffffff
mov edx, 0x80000000
sub ecx, edx
add ecx, ebx

Increment and decrement instructions
The INC instruction simply adds 1, while DEC subtracts 1. The following code results in eax becoming zero (0):
mov eax, 0xffffffff
inc eax

The following code results in eax becoming 0xffffffff:
mov eax, 0
dec eax
