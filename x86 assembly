### The registers are categorized as being one of the following:
-- General purpose registers
-- Segment registers
-- Flag registers
-- Instruction pointers


In x86 architecture, each general purpose register has its designated purpose and is stored at WORD size, or 16 bits, as follows:
-- Accumulator (AX)
-- Counter (CX)
-- Data (DX)
-- Base (BX)
-- Stack pointer (SP)
-- Base pointer (BP)
-- Source index (SI)
-- Destination index (DI)

Endianness
When reading or writing data to memory, we use the registers or memory to process them as BYTE, WORD, DWORD, or even QWORD. Depending on the platform or program, data is read
in little-endian or big-endian form. In little-endian, a chunk of data read into a DWORD is reversed. Let's take the following piece of data as an example:
AA BB CC DD
When the data on a file or memory looks like this, in little-endian format, it will be read as DDCCBBAAh in a DWORD value. 
This endianness is common to Windows applications.
In the big-endian system, the same chunk of data will be read as AABBCCDDh.
The advantage of using the big-endian form arises when reading streaming data such as file,  serial, and network streams.
The advantage of reading in little-endian is that the address you read it from remains fixed, regardless of whether it is read as BYTE, WORD, or DWORD. For example, consider the

Address Byte
0x00000000 AA
0x00000001 00
0x00000002 00
0x00000003 00

Copying data
The MOV instruction is used to move data. With this, data is moved either to or from a register or a memory address.
mov eax, 0xaabbccdd places the 0xaabbccdd value in the eax register.
mov eax, edx places the data value from theedx register to the eax register.

; the following lines reads from memory
mov al, byte ptr [00000071] ; al = 71h
mov cx, word ptr [00000071] ; cx = 7271h
mov edx, dword ptr [00000071] ; edx = 74737271h

; the following lines writes to memory mov eax, 011223344h
mov byte ptr [00000080], al ; writes the value in al to address 00000080
mov word ptr [00000081], ax ; writes the value in ax to address 00000081
mov dword ptr [00000083], eax ; writes the value in eax to address 00000083

----------------------------------------------------------------------------------------------------------

MOV and LEA
MOV is used to read the value at a given address, while LEA (Load Effective Address) is used to get the address instead:
mov eax, dword ptr [00000060] ; stores 63626160h to eax
mov eax, dword ptr [00000060] ; stores 00000060h to eax

; using MUL and ADD
mov ecx, 1111h
mov ebx, 2222h
mov eax, 2 ; eax = 2
mul ecx ; eax = 2222h
add eax, ebx ; eax = 4444h
add eax, 1 ; eax = 4445h

; using LEA
mov ecx, 1111h
mov ebx, 2222h
lea eax, [ecx*2+ebx+1] ; eax = 4445h
The preceding code shows that the six lines of code can be optimized to three lines using the LEA instruction.

Addition and subtraction
mov ecx, 0x7fffffff
mov ebx, 0x7fffffff

mov ecx, 0x7fffffff
mov edx, 0x80000000
sub ecx, edx
add ecx, ebx

Increment and decrement instructions
The INC instruction simply adds 1, while DEC subtracts 1. The following code results in eax becoming zero (0):
mov eax, 0xffffffff
inc eax

The following code results in eax becoming 0xffffffff:
mov eax, 0
dec eax

--------------------------------------------------------------------------------------------
Multiplication and division instructions
MUL is used for multiplication and DIV for division. In multiplication, we expect that multiplying values would exceed the capacity of the register value. 
Hence the product is stored in AX, DX:AX or EDX:EAX (long or QWORD):
mov eax, 0x80000000
mov ecx, 2
mul ecx
---------------------------------------------------------------------------------------------

JZ/JE ZF = 1 Jump if zero/Jump if equal
JNZ/JNE ZF = 0 Jump if not zero/Jump if not equal
JS SF = 1 Jump if sign
JNS SF = 0 Jump if not sign
JC/JB/JNAE CF = 1 Jump if carry/Jump if below/Jump if not above or equal
JNC/JNB/JAE CF = 0 Jump if not carry/jump if not below/Jump if above or equal
JO OF = 1 Jump if overflow
JNO OF = 0 Jump if not overflow
JA/JNBE CF = 0 and ZF = 0 Jump if above/Jump if not below or equal
JNA/JBE CF = 1 or ZF = 1 Jump if not above/Jump if below or equal
JG/JNLE ZF = 0 and SF = OF Jump if greater/Jump if not less or equal
JNG/JLE ZF = 1 or SF != OF Jump if not greater/Jump if less or equal
JL/JNGE SF != OF Jump if less/Jump if not greater or equal
JNL/JGE SF = OF Jump if not less/Jump if greater or equal
JP/JPE PF = 1 Jump if parity/Jump if parity is even
JNP/JPO PF = 0 Jump if not parity/Jump if parity is odd
JCXZ CX = 0 Jump if CX is zero.
JECXZ ECX = 0 Jump if ECX is zero.
LOOP ECX > 0 Jump if ECX is not zero. Decrements ECX.
LOOPE ECX > 0 and ZF = 1 Jump if ECX is not zero and zero flag is set. Decrements ECX.
LOOPNE ECX > 0 and ZF = 0 Jump if ECX is not zero and zero flag is not set. Decrements ECX.
